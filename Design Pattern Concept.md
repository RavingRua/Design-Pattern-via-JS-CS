# 设计模式

## 第一章 设计模式

在上世纪70年左右，一种被称为“**软件危机**”的现象在软件行业中出现了。落后的软件生产方式无法满足快速增长的计算机软件需求。不管是软件过程的需求和概念阶段还是开发与维护阶段都出现了众多问题。在这样的背景下，当时的人们提出了许多解决方案来解决软件行业生产力落后的问题，而**面向对象范型**的软件工程过程模型则是其中之一。

面向对象范型旨在解决从需求、分析、开发到维护流中的一系列软件工程问题，而**设计模式（Design Pattern）**则是对常见的软件工程过程的一层**抽象**。相比传统范型，面向对象软件在实际生产中有着众多优势，但是设计面向对象软件比传统范型更加困难，而设计**可复用**的面向对象软件将更加困难。设计模式不仅要解决基本的设计问题，更要把这些问题进行抽象，总结出可复用的面向对象设计模型，也就是设计模式。**不是任何问题都需要从头做起**，设计模式就是对前人所采用的优秀设计的抽象总结。

### 1.1 设计模式的定义

为了沟通，需要给设计模式下一个定义。四人帮（不要误会，是指 Erich Gamma，Richard Helm，Ralph Johnson 和 John Vlissides）在1994 年发表的《设计模式 - 可复用的面向对象软件的基础》（接下来称之为《设计模式》）描述了设计模式的**四个基本要素**[1.1]：

1. **模式名称（pattern name）**：一个助记名，确定了一个通用设计的主要方面；
2. **问题（problem）**：模式面对的问题，描述应该在什么情况下使用模式；
3. **解决方案（solution）**：描述了模式内部结构的组成已经相互关系；
4. **效果（consequences）**：描述了模式的作用以及选择模式时应该权衡的问题。

《设计模式》中对设计模式的**定义**为：“对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述”。

### 1.2 描述设计模式

《设计模式》中使用统一的格式来描述设计模式，每一个模式根据以下模板（template）被分为若干部分[1.3]：

#### 模式名和分类

模式名描述了模式的本质，模式的分类是《设计模式》中对这些模式的分类[1.5]。

#### 意图

意图回答了：模式的作用、基本原理、意图和解决的特定设计问题。

#### 别名

模式的其他名称。

#### 动机

用以说明一个设计问题以及如何用模式解决这个问题的特定情境。

#### 适用性

什么时候使用模式，使用模型来改进哪些设计问题，怎样识别这些情况。了解模式的适用性有助于在各种语言中使用模式的实现。

#### 结构

《设计模式》使用对象建模技术（OMT）对设计模式中的类进行图形化描述，UML 是 OMT 技术的一种。

#### 参与者

设计模式中的类与对象以及他们的职责。

#### 协作

模式的参与者如何与模式协作并实现职责。

#### 效果

模式怎样实现目标，需要做的权衡取舍，以及系统结构中与抽象模式无关可以独立改变的部分。

#### 实现

模式在实现时对于特定语言而言的细节问题。

#### 代码提示

用特定语言描述实现模式的代码片段。

#### 已知应用

实际生产中模式被运用的实例介绍。

#### 相关模式

哪些模式与当前模式相关，它们有哪些区别，应该如何协作。

### 1.3 模式分类

《设计模式》中为所有23种模式进行了编目[1.4]并对其进行了分类[1.5]。根据**目的**和**范围**进行分类。

目的指模式用来完成什么工作，包括创建型（Creational）、结构型（Structural）和行为型（Behavioral）。创建型和对象创建相关，结构型处理类和对象的组合，行为型描述类和对象怎样交互和分配职责。

范围指模式是用于类还是对象。类处理类与子类之间的关系，这些关系在编译时通过继承确定，是静态的。对象处理对象间的关系，是运行时动态的，大部分模式都是对象型的。

《设计模式》中给出了各个模式之间关系的具体说明图[1.5 图1-1]。

### 1.4 面向对象术语

设计模式是用来解决面向对象程序设计问题的，关于设计模式有一些常用面向对象术语，这些术语不是面向对象术语的全部。

#### 对象

面向对象程序由**对象（object）**组成，对象包含数据和对数据操作的过程。数据称为**成员**、**属性**或**字段**，过程称为**成员函数**或**方法**。

客户请求是执行对象操作的唯一方法，对象在收到**客户**的**请求（或消息）**后，执行相应操作。

#### 粒度

一个程序中的对象数量用**粒度**数来描述。同一个程序的多种设计的粒度数不尽相同，一般来说，同一个程序，粒度数较少，其中对象是**粗粒度**的，因为每个对象中所包含的代码行会更多，反之是**细粒度**。

#### 接口

对象中每一个成员函数的原型（函数名、参数列表、返回值）被称为**型构（signature）**。对象操作所定义的所有型构集合称为**接口（interface）**。接口是一种规范，实现接口的类需要根据型构的规范去实现每种操作。每个接口有一个**类型（type）**，用来标识接口的名字。和类相似，接口可以包含其他接口，包含其他接口的接口称为**子接口**，被包含的接口称为**超接口**。

接口是面向对象系统的基本组成部分，对象只有通过接口才能与外界交流。

#### 抽象类

一些类需要为其派生类定义公共接口，这些类称为**抽象类**。抽象类将一部分或全部接口的实现延迟到派生类中。

#### 混入类

混入类为其他类提供可选的接口（mixin）。混入类要求多继承，一些语言中同时继承混入类的派生类不会称为混入的派生类，这是为了避免**菱形问题**。

#### 类与接口

搞清楚类（class）与类型（type）的差别很重要[1.6.4.1]。一个对象的类定义了对象的实现（如定义了属性），也定义了对象内部状态操作（如静态成员和封装了的成员函数）。而对象的类型只和接口有关。即类是对整个对象的实现，而接口是对象操作的抽象（即定义了成员函数的型构）。

类继承和接口继承也存在不同。**类继承**本质上是使用基类的实现定义派生类的实现，是一种**代码共享**。**接口继承（子类型化）**描述一个对象什么时候能替代另一个对象，即用一个包含更多操作的对象代替原有的对象来工作，出现接口继承，就代表有一个功能更加强大的对象将在其他对方代替原对象进行更多工作。

后文中会注意区分类与类型，为了避免理解错误，使用类表示语言中的 class，使用接口类型表示 interface。

#### 针对接口编程

《设计模式》中的编程风格是一种针对接口的编程[1.6.4.2]。针对接口编程可以理解为使用语言中的抽象类和接口编程，在 C++ 中允许一个抽象类指针指向派生类对象，并调用抽象类中定义的成员函数。在设计得当的情况下，针对接口编程有两个好处：

1. 客户无需知道对象的特定类型，而只需调用对象上期待的接口
2. 客户无需知道对象是用什么类实现的，而只需知道定义接口的抽象类

因为不必关注对象内部具体实现（封装的作用），通过接口或抽象类来调用一个对象的接口减少了子系统实现中的依赖关系，也产生了**可复用**面向对象设计的原则：**针对接口编程，而不是针对实现编程**。

#### 白箱复用

类继承机制是一种**白箱复用（white-box reuse）**，因为继承的基类内部细节对于派生类来说是可见的，两者是 is-a 的关系。

#### 黑箱复用

对象组合（composition）是一种**黑箱复用（black-box reuse）**，因为被包含另一个类对象对于包含其的对象来说内部是不可见的，可见部分只有类型，即接口，两者是 has-a 关系。

#### 继承与组合

《设计模式》对继承与组合两种复用模式进行了评价[1.6.5.1]。

类继承是静态的，所有定义在编译时确定，派生类只能继承多态（如虚函数）有限地改变类的行为，或进行基类成员重定义。

类继承也有不足，在针对接口编程的情况下，多态只能依靠虚函数，重定义的方法无法被接口或抽象类指针调用。此外，由于派生类知道基类内部细节，在一定程度上打破了封装性。基类的与派生类关系密切，如果派生类自己的成员与基类成员耦合度过高（未二次封装），基类的改变也会导致派生类发生过多改变，导致维护困难。

对象组合通过接口调用对象，通过遵守接口约定，即使包含的对象内部发生较大变动，也不影响包含其的对象通过接口进行通信。只要接口类型一致，不同类的对象也可以交替使用，因为他们的接口没有什么不同。此外，由于急于接口编程，包含另一个对象的对象与被包含的对象有着最小的耦合度。

#### 委托

另一种复用方法是**委托（delegation）**。在委托方式下，有两个对象同时处理一个请求，其中一个对象会将某种操作委托给另一个对象执行。这种情形类似于派生类引用基类，基类是委托方，派生类是被委托方，在某些语言中体现为通过 super 指针调用基类方法。而委托则是由接收请求的对象将自己的指针交给被委托人，使得被被委托人可以引用委托者。

### 1.5 设计应支持变化

《设计模式》阐述了一些原则[1.6.7]来避免系统变化时进行重新设计，降低软件维护成本。

一些原因会导致设计需要重新进行，而对应设计模式给出了一些解决方案：

1. 显示指定一个类来创建对象：创建对象时指定类名将导致该对象的引用受类而不是接口的限制，不遵守约定可能导致问题的出现。在不稳定的程序中尽量避免这种使用方式，尝试使用接口类型或抽象类声明对象，作为调用对象方法的指针。对应的设计模式：
   + Abstract Factory
   + Factory Method
   + Prototype
2. 对特殊操作的依赖：为请求指定特殊操作时，完成该请求的方式就被固定了，这可能是一个代码段或函数调用。为避免将代码写死，可以进行二次封装，将特殊操作封装为一个函数。对应的设计模式：
   + Chain of Responsibility
   + Command
3. 对硬件和软件平台的依赖：一些算法可能需要调用硬件或软件平台的 API 支持，而这个算法可能需要运行在多个平台上。需用通过一种模式来封装这些算法对其他 API 的请求以降低耦合。对应的设计模式：
   + Abstract Factory
   + Bridge
4. 对对象表示和实现的依赖：一些客户知道对象内部细节，如类继承情景，需要降低客户与对象耦合度。对应设计模式：
   + Abstract Factory
   + Bridge
   + Memento
   + Proxy
5. 算法依赖：一些对象可能依赖于某个经常需要优化变动的算法，需要降低两者耦合度。对应设计模式：
   + Builder
   + Iterator
   + Strategy
   + Template Method
   + Visitor
6. 紧耦合：一些类之间的耦合度太大了，改变一个类就需要了解其他类的细节，导致维护困难。一些设计模式有助于实现低耦合的类群：
   + Abstract Factory
   + Command
   + Façade
   + Mediator
   + Observer
   + Chain of Responsibility
7. 用派生类扩充功能：类继承将导致封装性被破坏，并可能提高耦合度，必须使用类继承的场景下有一些可用的设计模式：
   + Bridge
   + Chain of Responsibility
   + Composite
   + Decorator
   + Observer
   + Strategy
8. 不方便修改的类：有时需要修改一个难以修改的类，或遇到需要修改但目标是个黑盒的问题。一些模式提供了修改方法：
   + Adapter
   + Decorator
   + Visitor

### 1.6 设计模式的作用

以三种常见的软件类型：应用、工具箱、框架为例，设计模式在其中有以下作用：

1. 应用：设计模式对于一个应用来说，可以提高其内部复用性、降低内部模块耦合度，因此可以降低维护成本，并为未来的扩展做准备；
2. 工具箱：一些应用会经常使用第三方提供的工具箱，工具箱的设计比应用更复杂，因为需要考虑各种各样的应用场景。设计模式可以提高工具箱的可复用性；
3. 框架：框架是为一类软件提供一组可复用的类。框架可能是底层或高层驱动，因此特别强调设计复用。设计模式比框架更加抽象，使用设计模式对框架的维护和扩展都有很大的帮助。

## 第二章 创建型模式

## 第三章 结构型模式

## 第四章 行为型模式

### 4.4 Iterator

#### 意图

迭代器（**Iterator**）提供一种方法顺序来访问一个作聚合对象中包含的其他对象，而不暴露聚合对象的其他内部表示。

#### 别名

游标（Cursor）。

#### 动机

一个聚合对象，如列表（List）会提供一个方法让外部访问其包含的数据，并暴露一组操作方法，但不暴露这些方法和自身容器的实现。**迭代器**模式的主要思想是将对这个列表的访问和遍历从数组对象中分离出来并放入一个迭代器对象中，这个迭代器不包含容器中的元素，但是可以通过它访问这些元素，而不用操作原列表对象。此外，迭代器还可以跟踪当前访问位置，并计算出下一个需要遍历的对象。这样，聚合类本身就不需要提供访问相关的操作接口。

迭代器本身是一个类：

![迭代器](.\img\4.4 Iterator\Iterator.png)

+ `First()`：初始化迭代器指针
+ `Next()`：访问容器中下一个元素
+ `IsDone()`：是否已经遍历完所有元素
+ `CurrentItem()`：访问当前指针指向的元素
+ `index`：当前元素下标

注意，这里的迭代器和列表是耦合的，客户必须知道自己正在操作的是一个列表的迭代器。为了让迭代器可以操作任意可迭代对象，可以通过**多态迭代**实现这个目标。如果有一个扩展的列表，可以使用定义了接口规范的抽象列表类和迭代器，并让扩展列表的类和迭代器类继承该抽象：

![抽象](.\img\4.4 Iterator\Abstract Iterator.png)

+ `First()`：初始化迭代器指针
+ `Next()`：访问容器中下一个元素
+ `IsDone()`：是否已经遍历完所有元素
+ `CurrentItem()`：访问当前指针指向的元素

客户使用时，只需定义一个抽象类指针 Iterator ，就可以同时使用两种迭代器。

#### 适用性

+ 访问一个聚合对象而不暴露内部实现
+ 支持聚合对象的多种遍历方式
+ 为不同类型的聚合对象提供统一接口（支持多态迭代）

#### 结构

![结构](.\img\4.4 Iterator\Struct.png)

#### 参与者

+ `Iterator`：迭代器抽象类，定义接口规范
+ `ConcreteIterator`：某个具体类的迭代器，操作具体类型的聚合类对象
+ `Aggregate`：聚合抽象类，包含一个创建迭代器的接口
+ `ConcreteAggregate`：某个具体类的迭代器，包含一个返回对应类迭代器的接口

#### 协作

`ConcreteIterator`将跟踪聚合中的当前对象，并计算出下一个需要遍历的对象。

#### 作用

1. 使用迭代器类型接口可以通过不同方式遍历一个聚合对象，只需更改接口引用的迭代器对象即可
2. 迭代器简化了聚合的类型接口，有关遍历操作由迭代器负责
3. 同一个聚合可以有多个遍历，因为这套系统由迭代器维护

#### 实现

许多语言实现了迭代器相关的功能，如 C++ 的 STL 库。在手动进行迭代器实现时，有一些需要注意的地方：

1. 谁来控制迭代：迭代器操作可能是内部也可能是外部的。在客户主动控制迭代器时，只能显示地向迭代器请求下一个元素；如果客户通过某个外部操作使用迭代器，除了请求以外，该方法还应该包括一些功能：
   + 返回当前元素
   + 返回当前元素索引
   + 提供客户交互接口（可以是一个回调）
   + 操作当前元素（可以在回调中返回元素的引用）
   + 操作整个聚合的容器（可以在回调中返回聚合对象本身的引用）
2. 谁定义迭代算法：通常在迭代器中定义迭代算法可以简化聚合的实现，这将利于在迭代器接口类型上实现不同的算法，但是这可能会需要访问聚合类的一些私有成员，破坏封装性。需要考虑的是迭代器应该直接访问聚合私有成员还是通过公有成员访问来降低耦合
3. 迭代器健壮性如何：在遍历聚合同时更改聚合可能是危险的，最常见的问题是使用迭代器访问聚合时删除了一个元素，而迭代器不知道遍历范围已经缩小，最终导致下标越界。健壮的迭代器应该保证：
   + 插入和删除操作不会干扰后续迭代，当迭代范围因为聚合上的操作变化时，迭代器应该有改变能力，如在聚合内部操作时通知迭代器，或由迭代器检测范围
   + 操作无需拷贝聚合中的容器本身，迭代器如需访问聚合成员应该使用引用的方式
4. 附加的迭代器操作：除了上述的迭代方法，可以考虑增加一些迭代器操作，如访问上一个元素
5. 迭代器的访问特权：由于要访问聚合私有成员，迭代器需要一些访问特权。可以通过嵌套类、委托或友元来实现
6. 空迭代器：考虑到可能的边界问题的处理，需要有一个特殊的空迭代器，其`IsDone()`方法将永远返回`true`，在请求一个空聚合的迭代器时，可以由空聚合自身进行判断并直接返回这一类迭代器对象，而不用在迭代器实现中定义检查空聚合的方法

